## IMPORTANT NOTE:
## When you use this page as a template for creating your project page:
##  * please remove all lines starting with two hashes (##)
##  * except the acl line, please keep that, but remove one hash, so it reads #acl ...
##  * fix the acl line so it has the correct page instead of the sample Project/...Group
#acl AdminGroup:admin,read,write,delete,revert 2013011352:read,write 2013011329:read,write 2013011326:read,write OS2016spring/TeacherGroup:read,write OS2016spring/ProjectGroup:read Project/ReadGroup:read All:
##master-page:Unknown-Page
##master-date:Unknown-Date
#format wiki
#language zh
<<TableOfContents()>>

= 2016年操作系统课程设计-计算机组成原理的MIPS32 CPU上的Linux移植 =
在本页面维护专题训练大实验"计算机组成原理的MIPS32 CPU上的Linux移植"的相关信息。老师、助教和选做课程设计的同学可修改该页面的内容。

实验目标描述：将Linux操作系统移植到计算机组成原理课设计实现的MIPS32 CPU上，并对其运行状态进行测试。可能的工作内容如下。

 1. 增强MIPS CPU，能够访问容量更大的SDRAM；
 1. 调研arch/mips中多种不同的MIPS变种，选取合适的作为hack的对象
 1. 基于QEMU实验，考察Linux Kernel使用了MIPS ISA的哪些feature
 1. 移植u-boot，或者自己开发简单的bootloader，用于引导kernel
 1. QEMU+硬件调试，将Kernel启动起来

实验参与者信息
||姓名 ||学号 ||电子邮箱 ||Git 账户 ||
||张宇翔 ||2013011352 ||电子邮箱 ||https://git.net9.org/zhangyx13/ ||
||王邈 ||2013011329 ||电子邮箱 ||https://git.net9.org/u/shanker ||




实验代码仓库：

 * [[https://git.net9.org/zhangyx13/NaiveMIPS-HDL|CPU HDL Project]]

 * [[https://git.net9.org/shanker/linux-naivemips.git|Kernel Source]]

 * [[https://git.net9.org/zhangyx13/naivemips-simple-program|NaiveBootloader]]

 * [[https://git.net9.org/zhangyx13/qemu-naivemips|QEMU-NaiveMIPS]]

参考资料：

 * https://www.linux-mips.org/wiki/Linux/MIPS_Porting_Guide
 * MIPS32规范-指令集：[[attachment:Mips_vol2_InstructionSetReference.pdf]]
 * MIPS32规范-特权资源：[[attachment:MIPS_Vol3.pdf]]

== 日志 ==
=== 20160515 Linux 成功运行！ ===
在尽可能裁剪Kernel和Busybox功能后，我们成功的让内核在8M内存的情况下进入用户态（用QEMU仿真）。由于之前已经解决了各种bug，我们将Busybox用initramfs机制打包进Kernel，然后在硬件上测试，成功进入用户态，各种命令工作正常。

Log：[[attachment:naivemips.png]]

下一步将移植到配置DRAM的DE2i开发板上，获得更大的内存，进而实现网络、USB、文件系统等功能。

=== 20160514 中断带来的bug调试过程 ===
在解决完early boot阶段的bug后，kernel panic在了初始化sysctl proc的函数中：

{{{
[    0.000000] Memory: 4752K/8192K available (1631K kernel code, 82K rwdata, 252K rodata, 140K init, 180K bss, 3440K reserved, 0K cma-reserved)
[    0.000000] NR_IRQS:128
[    0.000000] clocksource: MIPS: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 477815111568 ns
[    0.001004] sched_clock: 32 bits at 4MHz, resolution 250ns, wraps every 536870911875ns
[    0.078819] Console: colour dummy device 80x25
[    0.091119] Calibrating delay loop... 3.80 BogoMIPS (lpj=7616)
[    0.166135] pid_max: default: 32768 minimum: 301
[    0.208178] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
[    0.224359] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
[    0.309258] CPU 0 Unable to handle kernel paging request at virtual address 00000000, epc == 00000000, ra == 801fd998
[    0.333095] Oops[#1]:
[    0.339425] CPU: 0 PID: 0 Comm: swapper Not tainted 4.5.0+ #111
[    0.353255] task: 802dc610 ti: 802da000 task.ti: 802da000
[    0.365269] $ 0   : 00000000 10008000 802cc8be 00000065
[    0.377656] $ 4   : 802cc8bc 802cc8bc 00000001 80403c28
[    0.390109] $ 8   : fffffffc 8041eb3c 00000001 72657375
[    0.402569] $12   : 80402188 00000100 00000000 80126714
[    0.414976] $16   : 80403c00 8041eb28 8041eb00 802de79c
[    0.427522] $20   : 802cc920 803399d0 00000011 00000024
[    0.439940] $24   : 00000002 0000000c
[    0.452061] $28   : 802da000 802dbd68 80403c78 801fd998
[    0.464678] Hi    : 0000000d
[    0.471501] Lo    : 00000000
[    0.478480] epc   : 00000000   (null)
[    0.487841] ra    : 801fd998 insert_header+0x378/0x4b8
[    0.499424] Status: 10008003 KERNEL EXL IE
[    0.509168] Cause : 00000008 (ExcCode 02)
[    0.518352] BadVA : 00000000
[    0.525347] PrId  : 00018000 (MIPS 4Kc)
[    0.534970] Process swapper (pid: 0, threadinfo=802da000, task=802dc610, tls=00000000)
[    0.552143] Stack : 00000000 80418400 80403c00 8041b000 38e38e39 0000000c 802cc8bc 80403c28
      8041eb00 802e6130 80403c00 00000000 8041eb00 00000000 00000000 8041eb00
      8041eb00 00000001 fffffffe 801feb14 8041b016 802e6130 00000000 00000000
      00000000 801feca8 802d4154 802d4178 8041eb84 8041eb2c 802de6e8 802de6e8
      802dbe90 8041b000 8041b003 802e6130 00000000 00000000 00000000 801feca8
      ...
[    0.636197] Call Trace:
[    0.643258] [<801feb14>] __register_sysctl_table+0x49c/0x510
[    0.657023] [<801feca8>] register_leaf_sysctl_tables+0x120/0x20c
[    0.671626] [<801feca8>] register_leaf_sysctl_tables+0x120/0x20c
[    0.686266] [<801a5180>] cache_alloc_refill+0x4f0/0x674
[    0.699217] [<801fed44>] register_leaf_sysctl_tables+0x1bc/0x20c
[    0.713774] [<801a5338>] __kmalloc+0x24/0x110
[    0.724535] [<801fc968>] count_subheaders+0x58/0x94
[    0.736662] [<801ff014>] __register_sysctl_paths+0x194/0x218
[    0.750581] [<801f77b0>] proc_mkdir_data+0x80/0xc4
[    0.762679] [<802f136c>] sysctl_init+0x18/0x2c
[    0.773868] [<802eddc8>] start_kernel+0x528/0x574
[    0.785648] [<802ed4f8>] unknown_bootoption+0x0/0x2dc
[    0.798360] [<802926b0>] kernel_entry+0x0/0xa8
[    0.808991]
[    0.812710]
Code: (Bad address in epc)
[    0.821575]
[    0.827973] ---[ end trace cb88537fdc8fa200 ]---
}}}
从panic信息中可以看见，发生的是内存访问异常，并且Bad Vaddr和EPC都是0。可以确定应该是取指令阶段触发的异常，即jump到了0地址处。进一步测试发现，该问题出现位置不确定，并不是由于stack trace中的函数的代码造成的。比如增加调试打印后，panic就到了别的地方。基本可以确定是由于中断造成的问题（在此阶段，有定期发生的定时器中断）。

于是在异常入口处的汇编代码加了调试信息，输出了异常原因，发现在报告的TLBL异常之前都是定时器中断。我开始怀疑是定时器中断处理的代码造成了跳转到0地址问题，并且出现问题的地方应该是初期阶段，所以现场还没有被改变，ra寄存器中还是sysctl初始化代码的现场。然而靠添加手工调试断点（while(1)）等方法，并没有找到期望的jump到0的情况。

在各种手段定位不到问题后，改用硬件调试方法。使用逻辑分析仪抓PC的值，并用TLBL异常信号作触发。最终找到PC=0的地方的是中断处理返回的ERET指令。该指令会将PC设置为EPC的值，也就是说中断处理返回时EPC的值为0！

阅读genex.S中异常入口、出口的汇编代码。可以知道EPC和其他通用寄存器会在异常入口时保存至thread_info结构体（指针为gp寄存器）的regs成员中，遂在irq-mips-cpu.c代码plat_irq_dispatch()函数中打印保存的EPC的值，发现panic之前的中断处理中的确EPC的值0。于是进一步向前跟踪，在中断入口处以EPC=0为条件加手工断点。最终确定该中断发生时EPC的值就是0！

显然这在逻辑上是不可能的，因为地址0上没有代码（TLB还没有启用呢），只能是CPU实现的问题。于是研究CPU中EPC的datapath，发现了问题。在流水线运行过程中可能会插入空泡，这些空泡内容是空指令，地址设置为0。这些空泡在异常判断阶段时，如果正好遇上中断信号，进入异常入口时，EPC就会被设为0。于是修改CPU中的逻辑，异常检测时判断是否为空泡，只能在真正的指令上才能触发异常。

修改CPU中的问题后，重新测试，Kernel运行正常。

=== 20160511 内核调试小记 ===
在硬件上运行Linux遇到的问题及解决过程：

 1. 第一次在硬件上运行内核时，无任何输出。遂在start_kernel中增加prom_putchar，通过串口直接输出字符，确定串口正常。由于最开始的banner都没打印出来，怀疑硬件存在严重问题，就重新仔细核对了指令实现。发现sync和pref指令忘了实现o(╯□╰)o于是补充了一下（实现成NOP，原因见以前说明）。另外发现打开optimize for size后，增加了Branch Likely类指令，也没有实现，于是在编译选项中增加-fno-delayed-branch避免产生这些指令。编译后重新实验，内核日志打印，停在了Determined physical RAM map:  memory: 00800000 @ 00000000 (usable)后面

 1. 增加打印信息，跟踪到内核挂在了BUG()函数里面。阅读代码发现，MIPS架构自己实现了BUG和BUG_ON（arch/mips/include/asm/bug.h），用到了Trap和break指令，我们没有实现。直接注释掉，使用generic的BUG()实现。重新编译运行后，打印信息之处BUG发生在bootmem.c的——free()函数中。

 1. 为什么——free调用test_and_clear_bit会失败？我们将调用参数的值和qemu仿真时的值对比，发现是一样的，但是结果却不同，问题一定出在test_and_clear_bit中。通过反汇编和调试，发现是sllv指令结果出错。仔细阅读规范，发现我们之前实现有误，sllv应当只用rs寄存器值的低5位作为移位量，忽略高位。修改后该处函数调用正确通过。

=== 20160509 进度更新 ===
 * 修改QEMU，增加对NaiveMIPS的串口控制器的模拟，移植了陈宇恒学长的Flash硬件模拟
 * 实现NaiveMIPS的串口控制器在Linux下的驱动程序
 * 在QEMU中验证Bootloader从Flash中加载Kernel并引导的过程
 * TLB部分硬件逻辑改动完成，实现了ASID、G、V、D等字段，实现了TLB Invalid、TLB Mod异常，实现了TLBP指令

详细说明待补充

=== 20160505 近期工作说明 ===
'''QEMU修改'''

修改QEMU的指令实现、CP0实现情况，使之符合NavieMIPS硬件真实情况。详细修改如下：

@王邈 来填坑

'''内核TLB相关修改'''

内核中与MIPS32 TLB相关的代码位于arch/mips/mm/tlb-r4k.c，arch/mips/mm/tlbex.c文件中，修改其中的逻辑，去除了内核对Random、Wired寄存器，以及TLBWR指令的依赖。详细修改如下：

@王邈 来填坑

'''CP0硬件相关修改'''

TLB除了上述寄存器外，还有一些之前没实现的寄存器PageMask、Context。

 * PageMask寄存器用于指定页的大小。由于内核中我们指定页大小固定为4K，与之前NaiveMIPS实现相同，故不需要实现PageMask寄存器（直接忽略对PageMask写操作）。在QEMU中模拟实验同样证明，Linux只是在启动时设置PageMask为0（对应4K大小的页），之后不再更改。
 * Context寄存器是一个辅助寄存器。在发生TLB异常时，将虚拟地址高位部分（VPN2）存入Context，配合Context中预先设置的PTE字段，可以用于软件查找页目录。理论上该寄存器也可以用软件替代，但考虑其硬件实现非常简单，直接在硬件中实现了。

'''Bootloader+内核联合仿真'''

上学期课程中，我们实现了NaiveBootloader，该Bootloader可以将ELF文件中LOAD类型的段加载到指定的内存地址中。考虑到Linux内核编译出来的vmlinux文件实际上也是ELF，我们认为NaiveBootloader可以直接用于引导linux，因此用QEMU进行了实验。

MIPS32 CPU复位后的地址为0xBFC00000，也就是QEMU中-bios参数指定的二进制文件加载的位置。故我们使用命令

qemu-system-mipsel -M mipssim -bios boot.rom.bin  -m 16 -serial unix:/tmp/qemu.sock,server -nographic -monitor null -cpu 4Kc -s

将bootloader加载到启动地址处，而不是直接加载内核。(我们之前都是用-kernel vmlinux参数，直接让QEMU加载内核至内存，并跳至内核入口的）

同时我们还将串口重定向至unix套接字文件，通过socat工具：

socat -d -d unix-connect:/tmp/qemu.sock pty,raw

可以将unix套接字映射成虚拟终端，这样就可以用NaiveBootloader的上位机工具来加载内核：

serial_load.py --serial /dev/ttys005 -l vmlinux --term

这样的模拟实验验证了Bootloader通过串口加载内核并引导的整个过程，证明NaiveBootloader可以直接用于引导linux。

=== 补充前一阶段成果的详细说明 ===
'''硬件修改'''

 * 4条非对齐访存指令。总所周知，MIPS等RISC处理器上，正常的访存指令都只运行对齐的访存，例如lw要求4字节对齐，lh要求2字节对齐等。如果要实现非对齐的访存（例如char *ptr; *(int*)ptr=1;），编译器就会产生非对齐访存指令*wl和*wr，它们通常成对出现，把一个非对齐的字拆分为两个部分，这两部分都是对齐的，然后拼接起来。由于是编译器自动产生的指令，所以必须要实现。
 * wait指令。wait指令用于在idle线程中，使处理器处于低功耗状态，直到有中断发生。实际上，如果不考虑功耗，可以直接把他实现为空指令。
 * pref、sync指令。这两条指令都是用于指挥cache工作的，没有cache情况下可以作为空指令实现。
 * ssnop指令。这样一条特殊的空指令，用于清除CP0 Hazards，其二进制编码和ori指令一样，如果不特别处理，就是一条空指令。
 * CP0的PRid,Config*寄存器。这些寄存器都是提供CPU信息的，例如生产厂家、Cache大小、支持的指令集扩展等。实现时参照spec中的说明即可，由于NaiveMIPS功能很简单，大部分标识设为0就行了。
 * 中断向量地址。在MIPS32手册Vol3中，“5.2.1 Exception Vector Locations”一节的“Table 5-6 Exception Vector Base Addresses”表格中，说明了异常发生时CPU跳转到的地址。从中可见MIPS32 Release1和Release2是不同的。当CP0 Status BEV位为0时，Release1异常的入口为0x80000000，而Release2的异常的入口由Ebase寄存器指定。上学期使用的ucore-thumips系统用的是的Ebase寄存器（即Release2版本的方法），故我们实现了EBase寄存器，不是Release1的方法。然而，由于Ebase寄存器的默认值就是0x80000000，故为Release1编译的Linux内核即使不设置Ebase，仍然可以正确的使用的异常，故无需特别处理。

'''软件修改'''

 * 内核提供的feature去除机制：在Linux内核的arch/mips/include/asm/mach-*/目录下，可以放置一个cpu-feature-overrides.h文件，提供平台不支持的功能说明。可以去除的feature参考arch/mips/include/asm/cpu-features.h中的宏定义，要去除就define为0。例如#define cpu_has_watch 0可以去掉内核对CP0 Watch寄存器的依赖。
 * ll/sc指令去除：ll/sc指令用于实现变量的原子访问，在NaiveMIPS中没有实现，故通过#define cpu_has_llsc 0告诉内核不用ll/sc。在没有ll/sc的情况下，可以看到arch/mips/include/asm/atomic.h文件中，采用了开关全局中断的方法来实现原子操作。事实上，不支持ll/sc指令的处理器还有mach-ath25，其注释中指出芯片的ll/sc有问题，不能使用。
 * Watch寄存器去除：Watch寄存器用于内存断点实现。在ptrace等机制中会用到（参见ptrace_set_watch_regs函数）。NaiveMIPS没有实现，故通过#define cpu_has_watch 0去除。

=== 20160423 进度更新 ===
最近两周时间的进度：（本周由于ASC、科展等原因进度不多，主要是上一周的工作）

 * 指令集支持方面：增加非对齐访存指令支持（lwl,lwr,swl,swr），增加几条特权指令（cache,sync,wait,pref,ssnop）
 * CP0支持方面：增加提供CPU特性标识的寄存器（PRid,Config*），根据MIPS规范修正了中断向量地址（ucore用了release2的特性）
 * 内核修改方面：找到内核提供的feature精简机制（cpu-feature-overrides.h），从而去除了内核对Watch寄存器、ll/sc指令的依赖
 * 内存架构方面：减小cache容量（加快编译），新的Avalon-MM Master接口（为了连接DRAM控制器）修改中
 * TLB方面：必要特征添加（如Dirty位，读取操作等），进行中

=== 20160410 内核移植方案介绍 ===
[[attachment:plan.pdf]]

=== 20160407 内核移植方案确定 ===
根据前期调研，我们已经确定使用Kernel中的CPU_MIPS32_R1为hack的基础，在上面修改CPU支持代码使得能够在NaiveMIPS运行。现已porting了基于CPU_MIPS32_R1的板级支持代码，并能够在qemu中启动进入busybox用户态程序。同时也确认8M了内存确实无法满足系统需求（运行到用户态后OOM）。接下来会基于QEMU对当前的Kernel运行情况进行分析，得出Kernel运行所依赖的CPU feature，然后开始hack。

=== 20160323 实验平台准备中 ===
考虑到Thinpad上的硬件资源有限（主要是RAM容量不够），我们将使用DE2开发板作为实验硬件平台，其上运行计原课设计的NaiveMIPS处理器。目前手头有一块DE2开发板，计原课展示时也已经将NaiveMIPS移植到了DE2上。当前的目标是修改CPU总线接口，使其符合Avalon Memory-Mapped Master接口规范，以便与Altera提供的IP核（主要是SDRAM控制器）连接，这样就可以使用SDRAM作为主存，给Linux运行提供足够的空间。
